/************************************************************************
*
*               Copyright 2004 Mentor Graphics Corporation
*                         All Rights Reserved.
*
* THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION WHICH IS
* THE PROPERTY OF MENTOR GRAPHICS CORPORATION OR ITS LICENSORS AND IS
* SUBJECT TO LICENSE TERMS.
*
************************************************************************/
/************************************************************************
*
*   FILE NAME
*
*       ips_cmac_xcbc_aes.c
*
*   COMPONENT
*
*       IPS - Cipher MAC XCBC using AES
*
*   DESCRIPTION
*
*       This file contains the implementation of IPS API functions
*       for Cipher-MAC XCBC.
*
*   DATA STRUCTURES
*
*       None
*
*   FUNCTIONS
*
*       IPSEC_XCBC_MAC_SetKeys
*       IPSEC_XCBC_MAC_Init
*       IPSEC_XCBC_MAC_Update
*       IPSEC_XCBC_MAC_Final
*
*   DEPENDENCIES
*
*       string.h
*        ips_api.h
*        ips_externs.h
*
************************************************************************/

#if ( (defined(INCLUDE_NU_POSIX)) && (INCLUDE_NU_POSIX) )

#include "posix/inc/posix.h"

#ifdef POSIX_1_17
#include "posix_rtl/inc/string.h"

#else
#include "posix/rtl/inc/string.h"
#endif

#else
#include <string.h>
#endif

#include "networking/nu_net.h"
#include "networking/ips_api.h"
#include "networking/ips_externs.h"

#if (IPSEC_INCLUDE_XCBC_MAC_96 == NU_TRUE)

/*
========================================================================
XCBC-MAC Mode (ips_cmac_xcbc_aes.h, ips_cmac_xcbc_aes.c)

This module implements the XCBC-MAC algorithm. The
underlying block cipher could be any one of those supported by OpenSSL.

Notation

   b1^b2          This is the bitwise exclusive or of blocks 'b1' and
                  'b2'.  These blocks are assumed to be the same length.

   e(k,b)         This is the result of encrypting block 'b' using
                  algorithm 'e' and key 'k'.

   e-CBC-MAC(k,m) This is the authenticator produced by the CBC-MAC
                  algorithm given the message 'm' and the key 'k'.  In
                  practice, 'e' will be replaced by the name of a cipher
                  (e.g. 3DES-CBC-MAC).

Definition of XCBC-MAC

   The XCBC-MAC is a variation of the CBC-MAC algorithm.

   CBC-MAC is defined with regards to a specific shared key block cipher
   (Such as DES, 3DES or Blowfish).  It produces a message authenticator
   for arbitrary octet streams which can be verified by any entity
   sharing the key of the authenticator.

   The basic algorithm is only capable of authenticating messages which
   are an integral number of blocks in length.  Thus, for a given cipher
   and message, the message must be tail-padded the the closest block
   boundary using all zeroes.

   The message should be divided into sequential blocks P(0),...,P(n).
   The production of the authenticator can be described inductively:

                                 C(0) = e(k, P(0))

                                 C(i+1) = e(k, P(i+1)^C(i))

   The result e-CBC-MAC(k,m) is the result of C(n).

   The XCBC-MAC algorithm performs encrypted padding, thereby increasing
   the security of the hash. The initial Key is encrypted using three
   constants (RFC 3566) to generate a set of three Keys K1, K2 and K3. K1
   is used to encrypt the entire message. K2 and K3 are used for the
   padding. If the message is an exact multiple of the block size the last
   block is exactly the right size therefore no padding is done and the
   block is XORed with K2 and then with the previously encrypted block
   before encryption. If the message is not an exact multiple of the block
   size the last block is padded and XORed with K3 and with the previously
   encrypted block before encryption.

   Thus in case of XCBC-MAC the authenticator is described as follows.
                                C(0) = e(K1, P(0))
                    for all i<n    C(i+1) = e(k1, P(i+1)^C(i))

                                C(n)   = e(k1, P(n)^K2^P(n-1)) or
                                C(n)   = e(k1, P(n)^K3^P(n-1))
========================================================================
*/

/************************************************************************
*
*   FUNCTION
*
*       IPSEC_XCBC_MAC_SetKeys
*
*   DESCRIPTION
*        This function generates the three Keys required for XCBC_MAC
*       encryption. Three constants defined in RFC 3566 are used to
*       generate the three keys.
*       const1 = 0x01010101010101010101010101010101
*       const2 = 0x02020202020202020202020202020202
*       const3 = 0x03030303030303030303030303030303
*       Each key is generated by encrypting the respective constant using
*       AES encryption, the initial key is used for this encryption. The
*       three generated keys are placed in the set_key buffer.
*
*   INPUTS
*       *key                    Initial Key K.
*       *key_set                Empty buffer for set of generated keys
*                               'K1', 'K2' and 'K3'.
*       key_len                 Length of one key in bytes.
*
*   OUTPUTS
*
*       NU_SUCCESS              Indicates success.
*       IPSEC_INVALID_PARAMS    Error indicating invalid parameters.
*
*************************************************************************/
static STATUS IPSEC_XCBC_MAC_SetKeys(
                                     UINT8 *key,
                                     UINT8 *key_set,
                                     UINT8 key_len
                                     )
{
    UINT8 const1[] = {0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01};
    UINT8 const2[] = {0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02};
    UINT8 const3[] = {0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03};

    STATUS      status           = NU_SUCCESS;
    UINT8       iv[16];
    AES_KEY     temp_aes_key;

    /* Initialize context. */
    if(key_len == 0)
    {
        status = IPSEC_INVALID_PARAMS;
    }
    else if (0 == AES_set_encrypt_key(key, key_len * 8, &temp_aes_key))
    {
        /* Generate Key1. */
        memset(iv, 0, sizeof(iv));
        AES_cbc_encrypt(const1, const1, sizeof(const1), &temp_aes_key, iv, AES_ENCRYPT);
        memcpy(key_set, const1, key_len);

        /* Generate Key2. */
        memset(iv, 0, sizeof(iv));
        AES_cbc_encrypt(const2, const2, sizeof(const2), &temp_aes_key, iv, AES_ENCRYPT);
        memcpy(key_set + key_len, const2, key_len);

        /*Generate Key3. */
        memset(iv, 0, sizeof(iv));
        AES_cbc_encrypt(const3, const3, sizeof(const3), &temp_aes_key, iv, AES_ENCRYPT);
        memcpy(key_set + (key_len*2), const3, key_len);
    }
    else
    {
        status = IPSEC_INVALID_PARAMS;
    }
    return (status);

} /* IPSEC_XCBC_MAC_SetKeys */

/************************************************************************
*
*   FUNCTION
*
*       IPSEC_XCBC_MAC_Init
*
*   DESCRIPTION
*
*       This function initializes the XCBC-MAC context for the specified
*       block encryption algorithm and key, Dynamically allocates the
*       key schedule for the encryption algorithm within the MAC
*       context, Calls the key schedule initialization function of the
*       encryption algorithm by indexing the encryption algorithm
*       structure, and initializes the context.
*
*   INPUTS
*
*       *context                Context for XCBC-MAC.
*       *key                    Key for encryption.
*       key_len                 Length of one key in bytes.
*
*   OUTPUTS
*
*       NU_SUCCESS              Indicates success.
*       NU_NO_MEMORY            If memory allocation fails.
*       IPSEC_CRYPTO_ERROR      If crypto related error.
*       IPSEC_INVALID_PARAMS    Otherwise.
*
*************************************************************************/
STATUS IPSEC_XCBC_MAC_Init(
            IPS_CIPHER_MAC_CTX *context,
            UINT8 *key, UINT8 key_len
)
{
    STATUS status;

    context->data_len = 0;

    /* Allocate a buffer for the set of keys Key1 Key2 and Key3. */
    status = NU_Allocate_Memory(IPSEC_Memory_Pool, (VOID **)&(context->key_set),
                                (key_len*3), NU_NO_SUSPEND);
    if (status == NU_SUCCESS)
    {
        status = NU_Allocate_Memory(IPSEC_Memory_Pool,
                                    (VOID **)&(context->aes_key),
                                    sizeof(AES_KEY), NU_NO_SUSPEND);
        if (status == NU_SUCCESS)
        {
            memset(context->iv, 0, sizeof(context->iv));

            status = IPSEC_XCBC_MAC_SetKeys(key, context->key_set, key_len);

            if (status == NU_SUCCESS)
            {
                if (0 != AES_set_encrypt_key(context->key_set, key_len*8,
                                             context->aes_key))
                    status = IPSEC_CRYPTO_ERROR;
            }
        }
    }

    return (status);

} /* IPSEC_XCBC_MAC_Init */


/************************************************************************
*
*   FUNCTION
*
*       IPSEC_XCBC_MAC_Update
*
*   DESCRIPTION
*
*       This function updates the XCBC-MAC state using the specified
*       message. Any previously buffered bytes are prepended to the
*       message.  The last block is buffered in the context.  The
*       results of the latest encryption are stored in the context.
*
*   INPUTS
*
*       *context                Context for XCBC-MAC.
*       *message                Message to be included in the XCBC-MAC.
*       message_len             The length of the message.
*
*   OUTPUTS
*
*       NU_SUCCESS              Indicates success.
*
*************************************************************************/
STATUS IPSEC_XCBC_MAC_Update(
                             IPS_CIPHER_MAC_CTX *context,
                             UINT8 *message, UINT16 message_len
                             )
{

    STATUS      status = NU_SUCCESS;
    UINT8       block_len;
    UINT8       need;
    UINT16      nbytes;
    UINT16      leftover;

    /* Note what the block length of this algorithm is.*/
    block_len = IPS_XCBC_BLOCK_SIZE;

    /* Check if we have any buffered data in the context. If we do,
        copy enough data from the front of the message buffer to complete
        the temporary block in the context, then encrypt the temp block in
        the context, then encrypt the rest of the message.
    */
    if (context->data_len != 0)
    {
        /* Compute how many bytes we 'need' to fill up the temp block. */
        need = block_len - (UINT8)context->data_len;

        /* Make sure message contains enough bytes. */
        if ((UINT16)need <= message_len)
        {
            /* Message is at least long enough for us to copy the needed bytes.*/
            nbytes = need;
        }
        else
        {
            /* Copy what we have but we still won't have a full block. */
            nbytes = message_len;
        }

        if ((nbytes !=0) && (nbytes <= (IPS_XCBC_BLOCK_SIZE - context->data_len)))
        {
            memcpy(&context->tmp_data[context->data_len], message, nbytes);

            message        += nbytes; /* advance message pointer */
            /* message is shorter by this much */
            message_len    = message_len - nbytes;
            /* temp block is longer by this much */
            context->data_len  = context->data_len + nbytes;
        }

        /*If the message is now empty this could be the last 128 bits */
        if(message_len == 0)
        {
            return status;
        }
        /* If we have a full temp block encrypt it.*/
        if (context->data_len == (UINT16)block_len)
        {
            AES_cbc_encrypt(context->tmp_data, context->tmp_data, block_len,
                            context->aes_key, context->iv, AES_ENCRYPT);
            status = NU_SUCCESS;
            /* Indicate no more data in temp block */
            context->data_len = 0;

            /* After each encryption, copy the final block into the context.*/
            if (block_len <= IPS_XCBC_DIGEST_LEN)
                memcpy(context->tmp_digest, context->tmp_data, block_len);
        }
    }

    /* If we still have a message, process it.
    */
    if ((status == NU_SUCCESS) && (message_len != 0))
    {
        /* Determine the number of bytes (if any) in the partial block
           at the end of the message. The partial block at the end will be
           copied into the context, and won't be included in this round of
           encryption. */
        leftover = (UINT8) message_len % block_len;
        if (leftover != 0)
        {
            /* move the leftover bytes to the temp block in the
               context, and adjust the message length accordingly.*/
            memcpy(context->tmp_data, message+(message_len-leftover), leftover);

            /* message is shorter by this much. */
            message_len   = message_len - leftover;
            /* tempblock now contains this much. */
            context->data_len  = leftover;
        }

        else
        /*If the message is an exact multiple of the blocklength put the
          last block into the temp block. */
        {
            leftover = block_len;
            memcpy(context->tmp_data, message+(message_len-leftover), leftover);
            message_len    = message_len - leftover;
            context->data_len  = leftover;
        }
        /* If we still have a message, then it was two or more complete
           blocks. */
        if (message_len != 0)
        {
            AES_cbc_encrypt(message, message, message_len,
                            context->aes_key, context->iv, AES_ENCRYPT);
            status = NU_SUCCESS;
            /* After each encryption, copy the final block into the context. */
            memcpy(context->tmp_digest, message + (message_len - block_len), block_len);
        }
    }
    return (status);

} /* IPSEC_XCBC_MAC_Update */

/************************************************************************
*
*   FUNCTION
*
*       IPSEC_XCBC_MAC_Final
*
*   DESCRIPTION
*
*       This function finalizes the MAC/digest and stores it in the
*       user specified buffer.
*
*       The last block is encrypted here. Padding is done(if needed).
*       The block is XORed with Key 2 and encrypted if it is a complete
*       block, otherwise the necessary padding is done and the block is
*       XORed with Key3 before encryption.
*       The encrypted block is stored to the temporary digest buffer.
*
*       The contents of the temporary digest buffer are copied to the
*       digest. The digest length variable is set to equal the encryption
*       algorithm's block size.
*
*   INPUTS
*
*       *context                Context for XCBC-MAC.
*       *digest                 Buffer to receive the computed digest.
*       *digest_len             Pointer to variable to receive the
*                               digest length.
*
*   OUTPUTS
*
*       NU_SUCCESS              Indicates success.
*
*************************************************************************/
STATUS IPSEC_XCBC_MAC_Final(
                            IPS_CIPHER_MAC_CTX *context,
                            UINT8 *digest, UINT *digest_len
                            )
{
    STATUS      status;
    UINT8       block_len;
    INT         counter;
    UINT16      len;

    /* Note what the block length of this algorithm is. */
    block_len = IPS_XCBC_BLOCK_SIZE;

   /*If the data_len is equal to the block length XOR the block with the
     previous encrypted block and Key2,encrypt with Key1*/
    if (context->data_len == (UINT16)block_len)
    {
        /* XOR K2 with iv. */
          for(counter = 0; counter < block_len; ++counter)
        {
            context->iv[counter] ^=
                        context->key_set[counter + IPS_XCBC_KEY_SIZE];
        }

    }
    /*If the data_len is less than the block_len pad the data with a
      single 1 followed by the required number of zero bits to increase
      the data_len to match the block size, XOR with the previous
      encrypted block and Key3, encrypt with Key1. */
    else if(context->data_len < (UINT16)block_len)
    {
        /* Pad the data with 10* padding */
        memset(context->tmp_data+context->data_len,0x80,1);

        len = block_len-context->data_len-1;

        if ((context->data_len+1 < IPS_XCBC_BLOCK_SIZE) &&
            (len <= IPS_XCBC_BLOCK_SIZE - (context->data_len+1)))
        {
            memset(&context->tmp_data[context->data_len+1], 0, len);
        }

        /* The data is now padded. */

        /* XOR K3 with iv. */
          for(counter=0; counter <block_len; ++counter)
        {
            context->iv[counter] ^= context->key_set[counter +
                                     (IPS_XCBC_KEY_SIZE*2)];
        }
    }

    AES_cbc_encrypt(context->tmp_data, context->tmp_data, block_len,
                    context->aes_key, context->iv, AES_ENCRYPT);
    status = NU_SUCCESS;

    context->data_len = 0;/* Indicate no more data in temp block*/

    /* Copy the final block into the context. */
    memcpy(context->tmp_digest, context->tmp_data, block_len);
    /* At this point tmp_digest in the context contains our computed
       digest.*/
    memcpy(digest, context->tmp_digest, block_len);
    *digest_len = block_len;

    /* Free the key_set buffer and aes_key structure we allocated.*/
    NU_Deallocate_Memory(context->key_set);
    NU_Deallocate_Memory(context->aes_key);

    return (status);
} /* IPSEC_XCBC_MAC_Final */

#else /* (IPSEC_INCLUDE_XCBC_MAC_96 == NU_TRUE) */

/* stubs */

STATUS IPSEC_XCBC_MAC_Init(IPS_CIPHER_MAC_CTX *context,
                           UINT8 *key, UINT8 key_len)
{
    return IPSEC_NOT_FOUND;
}

STATUS IPSEC_XCBC_MAC_Update(IPS_CIPHER_MAC_CTX *context,
                             UINT8 *message, UINT16 message_len)
{
    return IPSEC_NOT_FOUND;
}

STATUS IPSEC_XCBC_MAC_Final(IPS_CIPHER_MAC_CTX *context,
                            UINT8 *digest, UINT *digest_len)
{
    return IPSEC_NOT_FOUND;
}

#endif /* (IPSEC_INCLUDE_XCBC_MAC_96 == NU_TRUE) */
