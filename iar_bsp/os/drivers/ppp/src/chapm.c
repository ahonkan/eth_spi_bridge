/*************************************************************************
*
*               Copyright 1997 Mentor Graphics Corporation
*                         All Rights Reserved.
*
* THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION WHICH IS
* THE PROPERTY OF MENTOR GRAPHICS CORPORATION OR ITS LICENSORS AND IS
* SUBJECT TO LICENSE TERMS.
*
**************************************************************************
**************************************************************************
*
*   FILE NAME
*
*       chapm.c
*
*   COMPONENT
*
*       MSCHAP - Microsoft Challenge Handshake Authentication Protocol
*
*   DESCRIPTION
*
*       This file contains the Microsoft challenge handshake
*       authentication protocol(MSCHAP) functions that are common
*       to both version 1 and 2 of the protocol.
*
*   DATA STRUCTURES
*
*       None
*
*   FUNCTIONS
*
*       CHAPM_Password_Hash
*       CHAPM_Challenge_Response
*       CHAPM_Des_Encrypt
*       CHAPM_Random_Number
*
*   DEPENDENCIES
*
*       nu_ppp.h
*       md4.h
*       des.h
*
*************************************************************************/
#include "drivers/nu_ppp.h"

#if((PPP_USE_CHAP_MS1 == NU_TRUE) || (PPP_USE_CHAP_MS2 == NU_TRUE))
#include "openssl/md4.h"
#include "openssl/des.h"

/*************************************************************************
*
*   FUNCTION
*
*       CHAPM_Passwd_Hash
*
*   DESCRIPTION
*
*       Use MD4 algorithm to irreversibly hash password into password
*       hash.
*
*   INPUTS
*
*       *passwd                     Password
*       *passwd_hash                Password hash computed by this
*                                   function
*
*   OUTPUTS
*
*       None
*
*************************************************************************/
VOID CHAPM_Passwd_Hash(INT8 *passwd, UINT8 *passwd_hash)
{
    /* Declaring Variables */
    UINT16          len;
    UINT8           i, j = 0;
    UINT8           *unicode_array;

    /* size of the uni-code password array will be twice the password
    length */
    len = (UINT16)(2 * strlen((CHAR *)passwd));

    /* allocate memory for the uni-code password array */
    if (NU_Allocate_Memory(MEM_Cached, (VOID **)&unicode_array, len,
                           (UNSIGNED)NU_NO_SUSPEND) != NU_SUCCESS)
    {
        NLOG_Error_Log("Failed to allocate memory for unicode array in password hash",
                       NERR_SEVERE, __FILE__, __LINE__);
    }

    else
    {
        /* clear the array */
        UTL_Zero(unicode_array,len);

        /* Ignoring the KW false positive warning.The "for loop" is traversed over 
           the length of string "passwd" so there is no chance that it can access the 
           element outside the boundary of passwd */
        /* convert the password to uni-code characters */
        for (i = 0; (UINT16)i < (len/2); i++)
        {
            unicode_array[j] = passwd[i];
            j = j + 2;
        }

        /* Irreversibly hash password into password hash using MD4, of len 16. */
        MD4(unicode_array, len, passwd_hash);

        /* deallocate the memory */
        if (NU_Deallocate_Memory((VOID*)unicode_array) != NU_SUCCESS)
        {
             NLOG_Error_Log("Failed to deallocate memory for unicode array in passwd hash",
                            NERR_SEVERE, __FILE__, __LINE__);
        }
    }

} /* CHAPM_Passwd_Hash */

/*************************************************************************
*
*   FUNCTION
*
*       CHAPM_Challenge_Response
*
*   DESCRIPTION
*
*       This function computes the response on the authenticator
*       challenge.
*
*   INPUTS
*
*       *chal                     8-octet challenge from the authenticator
*       *passwd_hash              16-octet hash of the password
*       *response                 24-octet response generated by this
*                                 function
*
*   OUTPUTS
*
*       None
*
*************************************************************************/
VOID CHAPM_Challenge_Response(UINT8 *chal, UINT8 *passwd_hash,
                              UINT8 *response)
{
    /* Declaring Variables */
    UINT8   zpasswd_hash[CHAP_MS_RESPONSE_SIZE] = {0};

    /* set zpasswd_hash to passwd_hash zero-padded to 21 octets */
    UTL_Zero(zpasswd_hash, 21);

    memcpy(zpasswd_hash, passwd_hash, CHAP_MS_PASSWD_HASH_SIZE);

    /* pass 1st 7-octets of zpasswd_hash. It will return 1st 8-octets of
    response */
    CHAPM_Des_Encrypt(chal, zpasswd_hash, response);

    /* pass 2nd 7-octets of zpasswd_hash. It will return 2nd 8-octets of
    response */
    CHAPM_Des_Encrypt(chal, &zpasswd_hash[7], &response[8]);

    /* pass 3rd 7-octets of zpasswd_hash. It will return 3rd 8-octets of
    response */
    CHAPM_Des_Encrypt(chal, &zpasswd_hash[14], &response[16]);

} /* CHAPM_Challenge_Response */

/*************************************************************************
*
*   FUNCTION
*
*       CHAPM_Des_Encrypt
*
*   DESCRIPTION
*
*       This function encrypts a string using DES encryption algorithm
*       in ECB mode.
*
*
*   INPUTS
*
*       *clear                      text to be encrypted
*       *key                        key for encryption
*       *cypher                     encrypted text
*
*
*   OUTPUTS
*
*       None
*
*************************************************************************/
VOID CHAPM_Des_Encrypt(UINT8 *clear, UINT8 *key, UINT8 *cypher)
{
    INT                 i;
    DES_key_schedule    schedule;
    UINT8               parity_key[8];
    UINT8               bits;

    /*
     * Use the DES encryption algorithm in ECB mode to encrypt clear into
     * cipher such that cipher can only be decrypted back to clear by
     * providing key.
     */

    /* Initially set shift bits value to zero. */
    bits = 0;

    /* Add parity bits to the 7 byte key. */
    for (i=0; i<7; i++)
    {
        /* Add least significant bit as parity. */
        parity_key[i] = (UINT8)(bits | (key[i] >> i));

        /* Keep record of bits to be shifted to next octet. */
        bits = (UINT8)(key[i] << (7-i));
    }

    /* Update last byte of key containing parity bits. */
    parity_key[i] = (UINT8)bits;

    /* Setup the key-schedule */
    DES_set_key((const_DES_cblock*)parity_key, &schedule);

    /* Make the request for encryption. */
    DES_ecb_encrypt((const_DES_cblock*)clear, (DES_cblock *)cypher, &schedule, DES_ENCRYPT);

} /* CHAPM_Des_Encrypt */

/*************************************************************************
*
*   FUNCTION
*
*       CHAPM_Random_Number
*
*   DESCRIPTION
*
*       This function generates a random number.
*
*   INPUTS
*
*       *random_number                  number generated by this function
*       *bytes                          size of the random number to be
*                                       generated. i.e. 8 bytes for MSCHAP
*                                       v1 and 16 for v2
*   OUTPUTS
*
*       None
*
*************************************************************************/
VOID CHAPM_Random_Number(UINT8 *random_number, UINT8 bytes)
{
     UINT32      rand_4bytes;
     UINT8 HUGE *pointer = random_number;
     UINT8       i;

     /*
      * if bytes == 8; generate a 8 byte long random number
      * if bytes == 16; generate a 16 byte long random number
      */

     for (i = 0; i < (bytes / 4); i++)
     {
         /* generate 4 byte random number */
         rand_4bytes = LCP_Random_Number32();

         /**/
         memcpy(pointer, (UINT8 *)&rand_4bytes, 4);
         pointer += 4;
     }

} /* CHAPM_Random_Number */

#endif /* (PPP_USE_CHAP_MS1 == NU_TRUE || PPP_USE_CHAP_MS2 == NU_TRUE) */
